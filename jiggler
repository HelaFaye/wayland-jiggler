#!/bin/bash

# --- CONFIGURATION ---
ACTION_LIMIT=60000      # 60 sec -> White & Draw
WARNING_LIMIT=30000     # 30 sec -> Red (Warning)
CHECK_INTERVAL=2        # Check every 2 seconds

# Files
STATE_FILE="/tmp/jiggler.state"
LOG_FILE="/tmp/jiggler.log"
MARKER="final-jiggler-process"

# Fix for ydotool path
YDO_BIN="/usr/local/bin/ydotool"
if [ ! -f "$YDO_BIN" ]; then YDO_BIN=$(which ydotool); fi
export YDOTOOL_SOCKET="/tmp/.ydotool_socket"

# --- HELPER FUNCTIONS ---

# Function to read idle time (Clean logic)
get_idle_time_raw() {
    gdbus call --session --dest org.gnome.Mutter.IdleMonitor \
      --object-path /org/gnome/Mutter/IdleMonitor/Core \
      --method org.gnome.Mutter.IdleMonitor.GetIdletime \
      | awk '{print $2}' | tr -dc '0-9'
}

case "$1" in
    --toggle)
        if pgrep -f "$MARKER" > /dev/null; then
            $0 --stop
        else
            $0 --start
        fi
        ;;

    --start)
        if pgrep -f "$MARKER" > /dev/null; then
            notify-send "Jiggler" "Already running!"
            exit 0
        fi

        # Reset state and log
        echo "ğŸŸ¢" > "$STATE_FILE"
        echo "--- JIGGLER STARTED ---" > "$LOG_FILE"

        # Start the background loop
        # We inject variables directly into the subshell to ensure they exist
        nohup bash -c "
            export YDOTOOL_SOCKET='$YDOTOOL_SOCKET'
            LOG_FILE='$LOG_FILE'
            STATE_FILE='$STATE_FILE'
            ACTION_LIMIT=$ACTION_LIMIT
            WARNING_LIMIT=$WARNING_LIMIT
            CHECK_INTERVAL=$CHECK_INTERVAL
            YDO_BIN='$YDO_BIN'

            # Define functions INSIDE to ensure scope correctness
            log_msg() {
                echo \"\$(date '+%H:%M:%S') | \$1\" >> \"\$LOG_FILE\"
            }

            move_square() {
                for axis in '5 0' '0 5' '-5 0' '0 -5'; do
                    for i in {1..20}; do
                        \$YDO_BIN mousemove -- \$axis
                        sleep 0.02
                    done
                done
            }

            log_msg \"ğŸŸ¢ System Ready. Limits: Warning=\${WARNING_LIMIT}ms, Action=\${ACTION_LIMIT}ms\"

            while true; do
                # Get Idle Time
                ms=\$(gdbus call --session --dest org.gnome.Mutter.IdleMonitor \
                  --object-path /org/gnome/Mutter/IdleMonitor/Core \
                  --method org.gnome.Mutter.IdleMonitor.GetIdletime \
                  | awk '{print \$2}' | tr -dc '0-9')
                
                if [ -z \"\$ms\" ]; then ms=0; fi
                
                # Math for logs
                sec=\$((ms / 1000))
                countdown=\$(( ( ACTION_LIMIT - ms ) / 1000 ))

                # --- LOGIC ---
                
                if [ \"\$ms\" -gt \$ACTION_LIMIT ]; then
                    # --- ACTION ---
                    echo \"âšª\" > \"\$STATE_FILE\"
                    log_msg \"âšª ACTION TRIGGERED! (Idle: \${sec}s). Drawing Square...\"
                    
                    move_square
                    
                    log_msg \"ğŸŸ¢ Action Done. Timer reset.\"
                    echo \"ğŸŸ¢\" > \"\$STATE_FILE\"
                    sleep 2

                elif [ \"\$ms\" -gt \$WARNING_LIMIT ]; then
                    # --- WARNING ---
                    echo \"ğŸ”´\" > \"\$STATE_FILE\"
                    log_msg \"ğŸ”´ WARNING: Inactive for \${sec}s. Action in \${countdown}s...\"

                else
                    # --- USER ACTIVE ---
                    echo \"ğŸŸ¢\" > \"\$STATE_FILE\"
                    if [ \"\$ms\" -lt 2000 ]; then
                         log_msg \"ğŸŸ¢ USER ACTIVE (Movement detected)\"
                    else
                         log_msg \"ğŸŸ¢ Monitoring... Idle: \${sec}s\"
                    fi
                fi

                sleep \$CHECK_INTERVAL
            done # $MARKER
        " >> /dev/null 2>&1 &

        notify-send "Jiggler" "ğŸŸ¢ STARTED" -i input-mouse
        ;;

    --stop)
        pkill -f "$MARKER"
        echo "âš«" > "$STATE_FILE"
        # Log stop manually since background process is killed
        echo "$(date '+%H:%M:%S') | âš« STOPPED manually." >> "$LOG_FILE"
        notify-send "Jiggler" "âš« STOPPED" -i input-mouse
        ;;

    --status)
        cat "$STATE_FILE" 2>/dev/null || echo "âš«"
        ;;

    --watch)
        if [ -f "$LOG_FILE" ]; then
            echo "ğŸ‘€ Watching Logs (Ctrl+C to exit)..."
            tail -f "$LOG_FILE"
        else
            echo "âŒ No log file found."
        fi
        ;;

    *)
        echo "Usage: jiggler {--start|--stop|--toggle|--status|--watch}"
        ;;
esac
exit 0